# Java Collections


## What is a Collections Framework?
A collections framework is a unified architecture for representing and manipulating collections. All collections frameworks contain the following:
  -  **Interfaces**: These are abstract data types that represent collections. Interfaces allow collections to be manipulated independently of the details of their representation. In object-oriented languages, interfaces generally form a hierarchy.
  -  **Implementations**: These are the concrete implementations of the collection interfaces. In essence, they are reusable data structures.
  -  **Algorithms**: These are the methods that perform useful computations, such as searching and sorting, on objects that implement collection interfaces. The algorithms are said to be polymorphic: that is, the same method can be used on many different implementations of the appropriate collection interface. In essence, algorithms are reusable functionality.


*Apart from the Java Collections Framework, the best-known examples of collections frameworks are the C++ Standard Template Library (STL) and Smalltalk's collection hierarchy. Historically, collections frameworks have been quite complex, which gave them a reputation for having a steep learning curve. We believe that the Java Collections Framework breaks with this tradition, as you will learn for yourself in this chapter.*


## Table of Contents
1. [Introduction to Java Collections Framework (JCF)](#introduction-to-java-collections-framework-jcf)
2. [Core Interfaces and Classes](#core-interfaces-and-classes)
    - [List Interface](#list-interface)
    - [Set Interface](#set-interface)
    - [Queue Interface](#queue-interface)
    - [Map Interface](#map-interface)
3. [Specialized Collections](#specialized-collections)
4. [Concurrent Collections](#concurrent-collections)
5. [Practical Applications](#practical-applications)
6. [Suggested Learning Path](#suggested-learning-path)
7. [Additional Resources](#additional-resources)


## Here is a Roadmap for Learning Java Collections
  1.  **Introduction to Java Collections Framework (JCF)**
        *  Overview of JCF: What it is and why it's used
        *  Interfaces and their implementations
            *  Collection Interface: Core interface in JCF
            *  Iterable Interface: Foundation of the Collection framework
  2.  **Core Interfaces and Classes**
      ### *List Interface*
        - **ArrayList**
          - Dynamic array, random access
          - Methods: `add`, `remove`, `get`, `set`, `size`
          - Time Complexity: O(1) for `get`, O(n) for `add` and `remove` (in worst case)
        - **LinkedList**
          - Doubly linked list
          - Methods: `add`, `remove`, `get`, `set`, `size`, `addFirst`, `addLast`, `removeFirst`, `removeLast`
          - Time Complexity: O(1) for `add` and `remove`, O(n) for `get` and `set`
        - **Vector**
          - Synchronized version of ArrayList
          - Methods: similar to ArrayList
          - Time Complexity: O(1) for `get`, O(n) for `add` and `remove` (in worst case)
        - **Stack**
          - Last-In-First-Out (LIFO) structure
          - Methods: `push`, `pop`, `peek`, `isEmpty`, `search`
      ### *Set Interface*
        - **HashSet**
            - No duplicates, no order
            - Methods: `add`, `remove`, `contains`, `size`
            - Time Complexity: O(1) for `add`, `remove`, and `contains`
        - **LinkedHashSet**
            - No duplicates, maintains insertion order
            - Methods: similar to HashSet
            - Time Complexity: O(1) for `add`, `remove`, and `contains`
        - **TreeSet**
            - No duplicates, sorted order
            - Methods: `add`, `remove`, `contains`, `size`, `first`, `last`, `higher`, `lower`
            - Time Complexity: O(log n) for `add`, `remove`, and `contains`
      ### *Queue Interface*
        - **PriorityQueue**
            - Elements ordered by natural ordering or by a Comparator
            - Methods: `add`, `offer`, `remove`, `poll`, `peek`
            - Time Complexity: O(log n) for `add` and `poll`, O(1) for `peek`
        - **LinkedList** (as a Queue)
            - Implements Queue methods like `add`, `offer`, `remove`, `poll`, `peek`, `element`
      ### *Map Interface*
        - **HashMap**
            - Key-value pairs, no order, no duplicates
            - Methods: `put`, `get`, `remove`, `containsKey`, `containsValue`, `size`, `keySet`, `values`
            - Time Complexity: O(1) for `put`, `get`, and `remove`
        - **LinkedHashMap**
            - Key-value pairs, maintains insertion order
            - Methods: similar to HashMap
            - Time Complexity: O(1) for `put`, `get`, and `remove`
        - **TreeMap**
            - Key-value pairs, sorted by keys
            - Methods: `put`, `get`, `remove`, `containsKey`, `size`, `firstKey`, `lastKey`, `higherKey`, `lowerKey`
            - Time Complexity: O(log n) for `put`, `get`, and `remove`
        - **Hashtable**
            - Synchronized version of HashMap
            - Methods: similar to HashMap
            - Time Complexity: O(1) for `put`, `get`, and `remove`
  4.  **Specialized Collections**
        - **EnumSet**
            - Specialized Set implementation for use with enum types
            - Methods: `allOf`, `noneOf`, `range`, `of`
        - **BitSet**
            - Represents a vector of bits that grows as needed
            - Methods: `set`, `clear`, `get`, `flip`, `length`, `size`
        - **Collections Utility Class**
            - Methods: `sort`, `shuffle`, `reverse`, `binarySearch`, `max`, `min`, `fill`, `copy`, `nCopies`, `singleton`, `unmodifiableCollection`
  5.  **Concurrent Collections**
        - **CopyOnWriteArrayList**
            - Thread-safe variant of ArrayList
            - Methods: `add`, `remove`, `get`, `set`, `size`
        - **ConcurrentHashMap**
            - Thread-safe variant of HashMap
            - Methods: `put`, `get`, `remove`, `containsKey`, `size`, `keySet`
  6.  **Practical Applications**
        - **Common Use Cases**
            - Choosing the right collection for the job
            - Performance considerations
            - Real-world scenarios and example projects
        - **Project Ideas**
            - Implement a simple in-memory database using maps
            - Develop a caching system with different eviction policies
            - Create a library management system using lists and maps
         


##Sources and Help
  -  [Java Collections Framework: Official Document](https://docs.oracle.com/javase/tutorial/collections/index.html)
  -  ChatGPT and Code Copilot

## Official Documentation:
  - [Java Collections Framework](https://docs.oracle.com/javase/tutorial/collections/index.html)
